#include <ros/ros.h>
#include <iostream>
#include <cstring>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <etsi_its_msgs/CPM.h>
//#include <flatbuffers/all_interface_generated.h> // This was generated by `flatc`.
//#include "flatbuffers/all_interface_generated.h" // This was generated by `flatc`.
#include "all_interface_generated.h" // This was generated by `flatc`.



using namespace Gos;

#define PORT 33211
#define BUFFER_SIZE 4096

ros::Publisher pub_cpm_; //@todo -- remove 

void decode_received_cpm() {
    int sockfd;
    struct sockaddr_in server_addr, client_addr;
    uint8_t buffer[BUFFER_SIZE];
    
    // Create a UDP socket
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }
    
    // Configure server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    // Enable multicast
    struct ip_mreq mreq;
    mreq.imr_multiaddr.s_addr = inet_addr("239.67.77.67");
    mreq.imr_interface.s_addr = htonl(INADDR_ANY);
    if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *)&mreq, sizeof(mreq)) < 0) {
        perror("setsockopt");
        exit(1);
    }

    // Bind the socket to the server address
    if (bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        exit(1);
    }
    
    while(ros::ok() == true){

        // Receive the message from the client
        socklen_t client_addr_len = sizeof(client_addr);
        ssize_t received_bytes = recvfrom(sockfd, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, &client_addr_len);
        if (received_bytes == -1) {
            perror("recvfrom");
            exit(1);
        }

        std::cout << "Received message from client: " << buffer << std::endl;

        auto msg = boost::make_shared<etsi_its_msgs::CPM>();
        flatbuffers::FlatBufferBuilder builder;

        std::cout<< "nb bytes " << received_bytes << std::endl;
        if(received_bytes > 150){
            auto gossip = GetGossipMessage(buffer);

            auto gossip_type = gossip->gossip_type();

            if (gossip_type == GossipType_FacilityLayerReception) {
                auto fac_rx = static_cast<const FacilityLayerReception*>(gossip->gossip()); // Requires `static_cast`

                std::cout << "Received a facility layer reception message" << std::endl;

                auto union_msg = fac_rx->msg_type();


                if(union_msg == FacilityLayerMessage_CAMessage){
                    std::cout << "Received a CAM " << std::endl;
                }
                else if(union_msg == FacilityLayerMessage_CPMessage){
                    std::cout << "Received a CPM " << std::endl;
                    auto cpm = static_cast<const CPMessage*>(fac_rx->msg());

                    //Decoding ITS header
                    const Gos::ItsPduHeader *header = cpm->header();

                    msg->header.stamp = ros::Time::now();
                    msg->its_header.protocol_version = header->protocol_version();
                    msg->its_header.station_id = header->station_id();
                    std::cout << "Station id " << msg->its_header.station_id << std::endl;

                    msg->generation_delta_time = cpm->generation_delta_time();
                    std::cout << "generation_delt_time " <<  msg->generation_delta_time << std::endl;

                    const Gos::ManagementContainer *mngmt_cntr = cpm->mgmt_container();
                    std::cout << "reference managment container info: " << std::endl;


                    //std::cout << "reference time: " << mngmt_cntr->reference_time() << std::endl;
                    const Gos::ReferencePosition *ref_pos = mngmt_cntr->reference_position();
                    std::cout << "reference position of the sending vehicle: lat = " << ref_pos->latitude() << ", long = " << ref_pos->longitude() << std::endl;
                    std::cout << "station type: " << mngmt_cntr->station_type() << std::endl;

                    // CpmManagementContainer
                    msg->station_type.value = mngmt_cntr->station_type();

                    msg->reference_position.altitude.value = ref_pos->altitude()->value();
                    msg->reference_position.altitude.confidence = ref_pos->altitude()->confidence();
                    msg->reference_position.latitude = ref_pos->latitude();
                    msg->reference_position.longitude = ref_pos->longitude();
                    msg->reference_position.position_confidence.semi_major_confidence = ref_pos->position_confidence()->semi_major_confidence();
                    msg->reference_position.position_confidence.semi_minor_confidence = ref_pos->position_confidence()->semi_minor_confidence();
                    msg->reference_position.position_confidence.semi_major_orientation = ref_pos->position_confidence()->semi_major_orientation();


                    const Gos::CpmPayload* c_payload = cpm->cpm_payload();

                    std::cout << "entered" << std::endl;
                    std::cout << "skipping decoding station data container" << std::endl;
                    #if 0
                    const Gos::OriginatingStationsContainer *o_stn_ctnr = c_payload->originating_stations_container();
                    if(o_stn_ctnr){
                        //originating vehicle container
                        
                        const Gos::OriginatingVehicleContainer *o_veh_ctnr = o_stn_ctnr->originating_vehicle_container();
                        std::cout << "entered" << std::endl;

                        if(o_veh_ctnr){
                            const Gos::Wgs84Angle *o_veh_orntn_angle = o_veh_ctnr->orientation_angle();
                            if(o_veh_orntn_angle){
                                std::cout << "vehicle orientation angle value: " << o_veh_orntn_angle->wgs_angle_value() << ", confidence: "<< o_veh_orntn_angle->wgs84_angle_confidence() << std::endl;
                            }    
                                msg->originatingVehicleContainer.yaw_rate.value = o_veh_orntn_angle->wgs_angle_value();
                                msg->originatingVehicleContainer.yaw_rate.confidence =o_veh_orntn_angle->wgs84_angle_confidence();

                            msg->originatingVehicleContainer.longitudinal_acceleration.value =  o_veh_ctnr->pitch_angle()->cartesian_value();
                            msg->originatingVehicleContainer.longitudinal_acceleration.confidence = o_veh_ctnr->pitch_angle()->cartesian_angle_confidence();

                        }
                        
                    } else{
                        msg->originatingVehicleContainer.heading.value = 0;
                    }
                    #endif

                    msg->has_sensor_information_container = false;
                    const Gos::PerceivedObjectContainer *pr_obj_cntr = c_payload->perceived_object_container();

                    if(pr_obj_cntr){

                    
                        std::cout << pr_obj_cntr << std::endl;

                        auto num_objs = pr_obj_cntr->number_of_perceived_objects();
                        std::cout << "here" << std::endl;
                        auto prcvd_objs = pr_obj_cntr->perceived_objects();
                        std::cout << "number of perceived objects: " << num_objs << std::endl;

                        if(num_objs > 0){

                            std::cout << "number of objects is not zero, count: " << num_objs << std::endl;

                            msg->has_list_of_perceived_object = true;
                            msg->numberOfPerceivedObjects = num_objs;

                            msg->listOfPerceivedObjects.perceivedObjectContainer = std::vector<etsi_its_msgs::PerceivedObject>();


                            for(auto obj : *prcvd_objs){

                                etsi_its_msgs::PerceivedObject rosObj;

                                rosObj.objectID = obj->object_id();
                                rosObj.timeOfMeasurement =  obj->measurement_delta_time();

                                std::cout << "Obj id " << obj->object_id() << std::endl;
                                std::cout << "Obj delta " << obj->measurement_delta_time() << " " << std::endl;

                                //object position
                                const Gos::CartesianPosition3dWithConfidence * pos = obj->position();
                                using cart_coord = const Gos::CartesianCoordinateWithConfidence;
                                cart_coord* x_cord = pos->x_cord();
                                cart_coord* y_cord = pos->y_cord();
                                cart_coord* z_cord = pos->z_cord();
                                std::cout << "Object positon: x-" << x_cord << ", y-" <<  y_cord << ", z-" << z_cord << std::endl;

                                rosObj.xDistance.value = x_cord->value() / 100;
                                rosObj.xDistance.confidence = x_cord->confidence();
                                rosObj.yDistance.value = y_cord->value() / 100;
                                rosObj.yDistance.confidence = y_cord->confidence();
                                rosObj.zDistance.value = z_cord->value();
                                rosObj.zDistance.confidence = z_cord->confidence();                 

                                //object velocity
                                const Gos::Velocity3dWithConfidence *vel = obj->velocity();

                                const Gos::VelocityPolarWithZ *pol_vel = vel->polar_velocity();
                                const Gos::Speed *vel_mag = pol_vel->velocity_magnitude();
                                std::cout << "VelocityPolarWithZ - speed: value= " << vel_mag->value() << ", conf = " << vel_mag->confidence() << std::endl;
                                const Gos::CartesianAngle *vel_dirct = pol_vel->velocity_direction();
                                std::cout << "VelocityPolarWithZ - direction: value = " << vel_dirct->cartesian_value() << ", conf = " << vel_dirct->cartesian_angle_confidence() << std::endl;
                                const Gos::VelocityComponent *pol_z_vel = pol_vel->z_velocity();
                                std::cout << "VelocityPolarWithZ - Z component: value= " << pol_z_vel->vel_comp_value() << ", conf = " << pol_z_vel->speed_confidence() << std::endl;

                                const Gos::VelocityCartesian *cart_vel = vel->cartesian_velocity();
                                const Gos::VelocityComponent *x_vel = cart_vel->x_velocity();
                                const Gos::VelocityComponent *y_vel = cart_vel->y_velocity();
                                const Gos::VelocityComponent *z_vel = cart_vel->z_velocity();
                                std::cout << "Object Cartesian velocity (value, confidence): x- " << x_vel->vel_comp_value() <<", "<<  x_vel->speed_confidence() 
                                                                                    << ", y- " << y_vel->vel_comp_value()<<", "<< y_vel->speed_confidence() 
                                                                                    << ", z-" << z_vel->vel_comp_value()<<", "<< z_vel->speed_confidence() << std::endl;

                                rosObj.xSpeed.value = vel_mag->value();
                                rosObj.xSpeed.confidence = vel_mag->confidence();
                                rosObj.ySpeed.value = vel_dirct->cartesian_value();
                                rosObj.ySpeed.confidence = vel_dirct->cartesian_angle_confidence();
                                rosObj.zSpeed.value = pol_z_vel->vel_comp_value();
                                rosObj.zSpeed.confidence = pol_z_vel->speed_confidence();


                                //@todo == check whether the assignment is true or not? Velocity component to accelaration?
                                rosObj.xAcceleration.value = x_vel->vel_comp_value();
                                rosObj.xAcceleration.confidence = x_vel->speed_confidence();
                                rosObj.yAcceleration.value = y_vel->vel_comp_value();
                                rosObj.yAcceleration.confidence = y_vel->speed_confidence();


                                //object dimensions
                                using obj_dim = const Gos::ObjectDimension;
                                obj_dim* z_dim = obj->object_dimension_z();
                                obj_dim* y_dim = obj->object_dimension_y();
                                obj_dim* x_dim = obj->object_dimension_x();

                                std::cout << "Object dimensions:(value, confidence): x- " << x_dim->value() <<", "<<  x_dim->confidence() 
                                                                            << ", y- " << y_dim->value()<<", "<< y_dim->confidence() 
                                                                            << ", z-" << z_dim->value()<<", "<< z_dim->confidence() << std::endl;

                                rosObj.planarObjectDimension1.value = x_dim->value();
                                rosObj.planarObjectDimension1.confidence = x_dim->confidence();
                                rosObj.planarObjectDimension2.value = y_dim->value();
                                rosObj.planarObjectDimension2.confidence = y_dim->confidence();
                                rosObj.verticalObjectDimension.value = z_dim->value();
                                rosObj.verticalObjectDimension.confidence = z_dim->confidence();

                                //object age
                                std::cout << "object age: " << obj->object_age() << std::endl;
                                rosObj.objectAge = obj->object_age();

                                auto obj_classifications_list = obj->classification();

                                for(auto obj_cls : *obj_classifications_list){
                                    const Gos::ObjectClass *obj_class = obj_cls->object_class();
                                    std::cout << "vehicle subclass: " << static_cast<int32_t>(obj_class->vehicle_sub_class()) << std::endl;
                                    std::cout << "object class confidence: " << obj_cls->confidence() << std::endl;

                                    rosObj.classification.value  = obj_class->vehicle_sub_class();
                                    // rosObj.classification.confidence  = obj_cls->confidence(); @todo -- no confidence field

                                    break; //@todo = remove this break, when the changes are made to receive list of classifications

                                }   


                                //map position
                                const Gos::MapPosition *map_pos = obj->map_position();
                                const Gos::MapReference *m_ref = map_pos->map_reference();
                                const Gos::RoadSegmentReferenceID *rd_seg = m_ref->road_segment();
                                std::cout << "MapPosition/roadseg: region = " << rd_seg->region()<< ", id: "<< rd_seg->id() << std::endl;
                                const Gos::IntersectionReferenceID *intrsctn_id = m_ref->intersection();
                                std::cout << "MapPosition/intersection: region = " << intrsctn_id->region()<< ", id: "<< intrsctn_id->id() << std::endl;


                                std::cout << "lane id: ", map_pos->lane_id();
                                std::cout << "conn id: ", map_pos->connection_id();
                                const Gos::LongitudinalLanePosition *long_lane_pos = map_pos->longitudinal_lane_position();
                                std::cout << "LongitudinalLanePosition - value= " << long_lane_pos->longitudinal_lane_position_value() << ", conf = " << long_lane_pos->longitudinal_lane_position_confidence() << std::endl;

                                rosObj.matchedPosition.laneID = map_pos->lane_id();
                                //@todo -- update the etsi_its_msgs::CPM with the relevant fields.

                                msg->listOfPerceivedObjects.perceivedObjectContainer.push_back(rosObj);

                            }
                        } else{

                            msg->has_list_of_perceived_object = false;
                            std::cout << " ================================== No objects in the list" << std::endl; 
                        }

                    } else{
                            msg->has_list_of_perceived_object = false;
                            std::cout << " ******** POC is empty" << std::endl; 
                    }
                    
                }
            }

            if (msg)
            {
                pub_cpm_.publish(msg);
            }
            else
            {
                std::cout << "Dropping the received CPM packet" << std::endl;
            }
        }
    } //while(true)
}



int main(int argc, char** argv)
{
    // Initialize the ROS node
    ros::init(argc, argv, "cpm_receive_node");

    // Create a ROS node handle
    ros::NodeHandle nh;

    // Create a ROS subscriber
    //ros::Subscriber sub = nh.subscribe("cpm_provided", 10, &serialize_cpm);
    pub_cpm_ = nh.advertise<etsi_its_msgs::CPM>("cpm_received", 20);

    
    decode_received_cpm();
    
    

    // ROS main loop
    ros::spin();

    return 0;
}
